## 1.1 SW 테스팅이 왜 필요한가?

### 1.1.1 SW 시스템 관점에서 테스팅의 필요성
```
테스팅은 소프트웨어 시스템의 문제를 최소화하기 위해 필요하다.
```

### 1.1.2 SW 결함의 원인
```
'장애'를 만드는 결함 / '결함'을 만드는 오류(Error)
하지만 모든 결함이 장애를 일으키진 않는다.
장애는 결함에 의해서만이 아니라 환경적인 조건에 의해서도 발생한다.
```
- `장애(Failure)`
	- 소프트웨어가 요구사항과 다르게 동작하는 것(즉, 프로그램의 실행결과와 요구사항에 명시된 결과에 차이가 있음을 의미)
- `결함(Defect)`
	- 소프트웨어 내에 장애를 유발할 수 있는 문제를 결함
- `오류(Error)` 
	- 이러한 결함이 생기게 한 개발자의 행위

### 1.1.3 SW 개발, 유지보수, 운영 시 테스팅의 역할
```
소프트웨어 개발 과정에서, 테스트레벨에 따른 테스팅은 소프트웨어 품질을 높이고, 고객에게 결함이 발생할 가능성을 최소화한다.
```

### 1.1.4 테스팅과 품질
```
테스팅을 통해 발견한 결함에 근거하여, 대상 소프트웨어의 기능 or 비기능적 요구사항과
품질특성(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 등) 관련 품질 측정이 가능하다.
```
- **테스팅이 결함을 찾아내고, 발견된 결함이 수정될 때 SW 시스템의 품질은 향상된다.**

### 1.1.5 테스팅은 얼마나 해야 충분한가? 
```
모든 조합을 테스트하는 것은 현실적으로 불가능하기 때문에 완벽한 테스팅은 없다.
테스트를 했을때 결함이 발생하지 않았다고, 프로그램에 결함이 없다고 말할 수 없다.
주어진 인력과 시간을 바탕으로 최대한 효과적이고 효율적인 테스트를 수행할 수 있도록 체계적인 테스트가 수행되어야 한다.
```

## 1.2 테스팅이란 무엇인가?
```
테스팅이란 응용프로그램 or 시스템의 동작과 성능, 안정성이
사용자가 요구하는 수준을 만족하는지 확인하기 위해 결함을 발견하는 매커니즘이다.
```
```
현재의 테스팅은 사용자의 기대 수준과 요구사항에 맞게 구현되고 동작하는지 확인하여 결함을 발견하고 
최종적인 결함 데이터를 근간으로 개발 프로젝트의 리스크 정보를 정량적 수치로 의사결정권자에게 전달하는 것
```

- `테스팅의 일반적인 목적`
	- 남아있는 결함 발견
	- 명세 충족 확인
	- 사용자 및 비즈니스의 요구 충족 확인
	- 결함 예방
- `관점에 따른 목적`
	- 개발과정 : SW의 결함을 찾아내고 수정하기 위해 가능한 많은 장애 상황을 만들어내는 것이 목적
	- 인수 테스팅 : 예상한 대로 시스템이 동작하는지 확인하고, 요구사항에 맞는지 확신을 얻는 것이 목적
	- SW의 품질을 평가하기 위한 테스팅 : 특정 시간에 시스템을 출시하는 것의 리스크를 개발 프로젝트 관리자에게 전달하는것이 목적
	- 유지보수 테스팅 : 개발 과정엣서 변경 작업이 일어나는 경우 새로운 결함이 유입되었는지 확인하는 것 목적(리그레션 테스팅 과정 포함)
	- 운영 테스팅 : 신뢰성 또는 가용성과 같은 시스템의 특성을 평가하는 것이 목적
- `테스팅` 
	- 결함을 발견하기 위한 활동
- `디버깅` 
	- 결함의 원인을 밝히고 코드를 수정하는 개발 활동

## 1.3 테스팅의 일반적인 원리
- `원리 1 - 테스팅은 결함이 존재함을 밝히는 활동이다.`
	- 결함이 전혀 발견되지 않은 경우라도 해당 SW이 결함이 없다고 할 수 없다. 테스팅은 결함이 존재함을 밝히는 것이다.
- `원리 2 - 완벽한 테스팅은 불가능하다(무한경로, 무한입력값, 무한타이밍)`
	- 조합이 무수히 많기 때문에 테스트 대상의 리스크 분석을 토대로 테스트 활동의 노력을 차별화하는것이 옳다.
- `원리 3 - 테스팅의 개발 초기에 시작한다.`
	- 테스팅 결과를 단기간에 알수있고, 전체 테스팅 기간을 단축할 수 있다. 코딩에서의 재작업을 줄여 개발기간을 단축할 수 있고 개발 후반에 발견될 결함을 예방할 수 있다.
- `원리 4 - 결함 집중`
	- 대다수의 결함들은 소수의 특정 모듈에 집중되어 발생하는 경향을 보이며, 이러한 결함의 집중은 운영상의 장애를 초래한다.
	- 결함이 집중 될 수 있는 모듈의 예
		- 자체적으로 복잡한 구조의 모듈
		- SW나 시스템의 다른 부분 또는 다른 모듈과 다량의 복잡한 상호작용을 하는 모듈(복잡한 인터페이스)
		- 기존에 개발된 것을 재사용하지 않고 새롭게 개발한 모듈
		- 크기가 큰 모듈
		- 경험이 미흡한 개발팀에서 개발한 모듈
- `원리 5 - 살충제 페러독스`
	- 동일한 TC로 동일한 테스트를 반복적으로 수행한다면 더이상 새로운 결함을 찾아내지 못한다.
	- TC를 정기적으로 리뷰하고 개선 할 필요가 있다. 
	- 탐색적 테스팅, JIT 테스팅 등의 경험 기반 접근법을 통해 새로운 TC를 추가하는 것이 필요하다
-`원리 6 - 테스팅은 정황에 의존적이다.`
	- 테스팅은 정황에 따라 다르게 진행된다.
	- 예 : 안전 최우선 SW를 테스트하는 경우, 전자상거래 사이트를 테스트할 때와는 다른 방식으로 진행해야함
-`원리 7 - 오류, 부재의 궤변`
	- 개발된 시스템이 사용자의 필요와 기대에 부응하지 못하고 사용성이 현저히 낮다면 결함을 찾고 수정하는 과정은 아무 소용없다.
	- 요구사항을 충족시키지 못한다면 결함을 모두 제거했더라도 품질이 높다고 볼 수 없다.

## 1.4 테스트 프로세스의 기초
```
프로세스 내의 활동들은 중복되거나 동시에 발생할 수 있다.
```

### 1.4.1 테스트 계획과 제어(통제)
- `테스트 계획 수립` : 테스트의 목표와 임무를 달성하기 위해, 이를 면밀히 확인하고 필요한 활동을 정의하는것
- `테스트 제어` : 계획 대비 실제 진행상황을 비교하는 지속적인 활동

### 1.4.2 테스트 분석과 설계
- `테스트 분석과 설계` : 일반적이고 추상적인 테스팅 목적을 **실제적이고 구체적인 테스트 상황과 테스트 케이스로 변환하는 활동**

### 1.4.3 테스트 구현과 실행
- `테스트 구현과 실행` : **가장 효율, 효과적으로 테스트를 실행하기 위하여 TC를 조합**하고 테스트 실행에 필요한 다른 정보를 포함하는 테스트 프로시저 또는
테스트 스크립트를 명세화 하는 활동

### 1.4.4 테스트 완료조건과 리포팅
- `완료 조건 평가` : 초기에 정의된 테스트 목표에 비해 **어느정도 실제 테스트가 수행되었는지**를 평가하는 활동
- 테스트 목표를 달성하였다면 테스트가 완료되고, 그렇지 않다면 추가 테스트를 통해 테스트 목표를 달성할지 아니면 목표를 변경하여 테스트를 완료할 것인지를 결정
- **해당 활동은 테스트 레벨마다 수행되는 것이 원칙(*테스트 레벨 : 컴포넌트, 통합, 시스템, 인수 테스팅)
- `리포팅` : **진행보고**와 **릴리즈 조언 및 최종보고** 형태로 이루어지며 테스팅을 수행하면서 수집한 결함 및 테스트 진행 관련 데이터를 가공하여 메트릭으로 수치화하고
관련 정보를 표현하는 작업
- `진행보고` : **'테스트 제어' 활동 단계에서 테스트의 진행 상황을 모니터링하는 활동**으로 분류되고, 
- `릴리즈 조언과 최종보고` : **테스트 완료단계에서의 활동**

### 1.4.5 테스트 마감 활동
- `테스트 마감` : 완료된 테스트 활동에서 데이터를 수집하여 테스트에서 발견된 사실 및 수치적 데이터와 함께 테스팅 경험과 테스트웨어를 종합하고 축적하는 활동

## 1.5 테스팅 심리학
```
독립성 높은(sw개발과 관계가 적은) 인원이 테스트를 수행하는 것이 결함과 장애를 찾아내는데 효과적이다.
```
- 테스트를 진행하는 동안 결함을 식별하는 과정을 테스트 대상 제품이나 작성자에 대한 비판으로 오해될 소지가 있는데
이를 해소하기 위해 시스템에서 결함을 찾아내는 능력은 호기심, 전문적비평, 비판적인 시선, 세밀한 것에 주목하는 태도, 원할한 의사소통, 결함을 유추해내는 경험을 필요로한다.

##1.6 SW 테스팅을 제약하는 요소
1) 관리자나 테스터가 테스팅에 대해 너무 단편적으로 알고있다는 것
2) 의사결정권자 또는 매니저들의 테스팅에 대한 인식부족
3) 테스팅을 불필요한 비용으로 보는것

## 1.7 테스팅 분야의 매력
- sw테스팅의 체계적인 지식 체계를 갖는 '전문분야'이다

## 1.8 테스트 전문가
- sw테스트 전문가에 대한 수요는 급격히 증가하고 있다.
- 이와 더불어 소비자의 품질에 대한 마인드나 기대수준이 높아지고 있다.

## 2.1 SW 개발모델
```
테스팅은 SW  개발 활동과 독립적으로 존재하지 않고 밀접하게 연계되어 있으므로,
개발 생명 주기 모델에 기반하여 테스트 접근법을 다르게 적용해야한다.
```

### 2.1.1 V-모델(순차적 개발모델)
- V-모델은 [요구사항 정의 및 분석, 시스템 설계, 구현, 테스팅] 이라는 일련의 단계(과정)을 통해 SW(시스템)를 순차적으로 개발하는 폭포수 개발모델에 근간을 두고 있다.
- 테스팅은 한번에 이뤄지는게 아니라 각각의 개발 단계에 대응하는 테스트 레벨이 별도로 존재하며 V모양을 이룬다. * 반드시 1 대 1 대응은 아니다.
- V-모델에서 제시하는 테스트 레벨은 **컴포넌트 테스팅, 통합 테스팅, 시스템 테스팅, 인수 테스팅 ** 등이 있다.
- 소프트웨어 개발기간 중 개발 산출물은 하나 또는 테스트 레벨에서 테스트 베이시스가 된다.

![image](https://github.com/ashgraey/istqb_ctfl/assets/123621863/e2f9da99-b98f-49bc-81e6-0b4351f69ac4)

```
V-모델을 통해 테스팅의 몇가지 기본 개념을 이해할 수 있다.
```
1) 테스트 레벨은 개발 단계와 대응하는 [컴포넌트 테스팅, 통합 테스팅, 시스템 테스팅, 인수 테스팅]을 의미한다.
	- 각각의 테스트 레벨은 서로 독립적이어서, 각 테스트 계획과 전략, 테스트 기법, 테스트 수행주체, 테스트 완료기준 등이 달라진다.
2) 개발 초기에 테스팅을 수행한다는 것은 개발 산출물을 리뷰 형태로 검토하면서 결함을 발견하는 정적 테스팅을 의미한다.
	- 정적 테스팅 동안에는 테스팅 관점에서 TC를 만들면서 결함을 발견하여 리뷰에 기여할 수 있다.
	- 결정테이블테스팅, 상태전이테스팅, 유즈케이스테스팅 등이 정적 테스트 과정에서 활용할 수 있는 설계 기법이다.
3) 결함예방 차원에서의 테스팅이 의미하느 바는, 개발 초기의 테스팅을 통해 개발 후반에 발생할 테스팅 비용을 줄일 수 있다.
	- 조기에 테스트를 설계함으로써 소프트웨어의 결함을 사전에 예방하는 효과를 얻음
4) 베리피케이션과 밸리데이션(V&V)은 소프트웨어 개발 생명 주기의 모든 전 단계에서 수행될 수 있다.
	- 베리피케이션(Verification)은 개발 산출물이 그 단계의 초기에 설정된 조건을 만족하는지 여부를 확인하는 프로세스를 의미한다.
	- 밸리데이션(Validation)은 명시되지는 않았지만 사용자의 관점에서의 요구사항이 만족하는지를 평가, 검증하는 프로세스를 의미한다.

### 2.1.2 반복적 - 점증적 개발 모델
- 반복적-점증적 개발방법은 [요구사항 분석, 시스템 설계, 구현, 테스팅]하는 개발 주기가 짧게 연속적으로 반복하는 활동으로 이뤄진다.
- 결함이나 장애를 조기에 발견하고 제거할 수 있기 때문에 개발 리스크를 조기에 감소시킬 수 있는 장점이 있다.
	- 반복적으로 개발하는 모델의 예 - (애자일 개발모델 RUP, RAD, 이해관계자 중심의 SW 개발, 프로토 타이핑)
- 하나의 반복 단계에서 개발한 결과물은 현재의 반복에서 추가 개발한 증분에 의해 규모가 점차 커지는데, 이때 해당 반복단계의 증분도 테스팅 하고,
부분 시스템 역시 리그레션 여부의 확인 목적으로 테스팅 해야한다.
- 리그레션 테스팅은 첫번때 반복 단계에서 테스팅 한 이후로 모든 반복단계에서 수행되어야 하므로 반복단계가 거듭될수록 중요해진다.
- 반복 단계별로 각각의 증부 산출물을 포함한 부분 시스템을 대상으로 베리피케이션과 밸리데이션을 수행할 수 있다.
- **애자일 개발 모델의 몇가지 특징**
	- 테스트를 미리 설계하지 않을 수 있으며, 누구나 테스트에 적극 참여할 수 있다.(개발자, 사용자, 테스터)
	- 애자일 테스팅은 결함을 최대한 빨리 발견하도록 해준다. 요구사항을 개발함과 동시에 결함을 발견할 수 있다.
	- 애자일 테스팅은 문서를 최고화한다.
	- 개발완료는 테스트 완료를 의미한다. 즉 개발과 테스트가 같이 시작되고 때로는 테스트가 먼저 시작된다.

### 2.1.3 개발 수명 주기 모델에서의 테스팅
```
성공적인 테스팅을 위해서는 그 개발 수명주기 모델에 관계없이 다음 요건들이 필요하다.
```
- 모든 개발 활동은 이미 상응하는 테스팅 활동을 동반한다.
- 각 테스트 레벨은 그 레벨에 맞는 특정한 목적을 갖고 있다.
- 주어진 테스트 레벨에 맞는 테스트의 분석과 설계는 대응되는 개발 활동안에 시작되어야한다.
- 개발 수명 주기 동안에 개발 산출물의 초안이 작성되면, 테스터는 이런 문서를 리뷰하는 활동에 참가해야한다.

## 2.2 테스트 레벨
```
테스트 레벨의 특징에 맞게 다르게 정의되고 식별되어야하는 사항들이 존재한다.
```
- 테스트 레벨의 일반적인 목표(목적)
- TC를 도출해 내는데 참조되는 개발 산출물(테스트 베이시스)
- 테스트 대상
- 발견된 전형적인 결함과 장애
- 테스트 하네스(드라이버/스텁) 필요 여부와 툴 지원의 필요성

### 2.2.1 컴포넌트 테스팅(= 단위 테스팅 = 유닛 테스팅)
```
컴포넌트 테스팅은 테스트가 가능한 최소 단위로 나누어진 SW내에서 결함을 찾고 그 기능을 검증하는것
```
- 컴포넌트 테스팅은 구조적인 테스팅(분기 커버리지 등)은 물론 기능성 테스트와 리소스 관련(메모리 유출 등) 테스팅 또는 강건성(Roubustness)테스팅과 같은 특정 비기능 테스팅을 포함한다.
- 일반적으로 컴포넌트 테스팅은 프로그램 소스 코드를 중심으로 테스트를 설계하며, 주된 테스팅 방법은 구조기반(화이트 박스) 테스팅이다.
- 동등분할 & 경계값분석 테스팅과 같은 명세기반 기법을 적용하기도 한다.
- **컴포넌트 테스팅의 일반적인 목적**
	- 기본 경로를 확인
	- 모든 오류 처리 경로를 확인
	- 컴포넌트 내의 인터페이스 확인 
	- 로컬 데이터 확인, 경계값 확인 

### 2.2.2 통합 테스팅
```
통합테스팅은 컴포넌트간의 인터페이스를 테스트 하는것은 물론, 시스템의 각기 다른 부분과 상호 연동하는 동적을 테스트를 의미
``` 
- 통합테스팅은 하나 이상의 테스트 레벨이 있을 수 있으며, 다양한 크기의 테스트 대상에 대해 수행될 수도 있다.
- 통합하는 범위가 클수록 장애나 결함의 위치를 찾기 어렵고, 이는 개발의 리스크를 증가시키기도 한다.
- 따라서 상향식, 하향식, 백복 통합과 같은 순차적이고 체계적인 통합전략이 한번에 통합하는 빅뱅전략보다 리스크를 줄이는데 효과적이다.
![image](https://github.com/ashgraey/istqb_ctfl/assets/123621863/68c95956-7a26-4429-b863-de064a757f22)
- 통합 테스팅은 기능적 특정은 물론, 특정한 비기능적 특성(성능, 연결성 등)을 테스팅 해야한다.
- 통합테스팅의 설계는 기능적 접근법, 구조적 접근법을 모두 사용하여 통합 그 자체에만 집중하는 오류를 범하지 않아야한다.

### 2.2.3 시스템 테스팅
```
시스템 테스팅은 전체 시스템 또는 제품의 동작에 대해 테스트하는 것이다. 
시스템 테스팅은 가능한 범위에서 실제 최종 사용 환경 또는 이와 유사한 환경에서 수행해야한다.
```
- **시스템 테스팅의 수행의 근간은 아래와 같은 상위 레벨의 테스트 베이시스(개발 산출물 등)이다.**
	- 리스크 분석서
	- 요구사항 명세 
	- 비즈니스 프로세스
	- 유즈 케이스
	- 기타 비즈니스 레벨의 시스템 동작 명세
	- OS 및 시스템 리소스와의 상호작용 명세
- 시스템 테스팅은 기능 및 비기능 요구사항을 모두 검증해야한다.
- 기능적 요구사항의 시스템 테스팅은 테스트 대상의 특성을 상세하게 대해 명세한 문서를 기반으로 테스트를 설계하는 명세기반(블랙박스)기법을 수행
- 비기능적 요구사항의 시스템 테스팅은 SW의 기능적 품질특성 외의 나머지 부분에 대한 요구사항 검증을 수행
	- 예 : 성능 테스트, 가용성 테스트, 보안성 테스트 등이 있다. 
- 시스템 테스팅은 독립적인 테스트팀이 수행하는 경우가 대부분

### 2.2.4 인수 테스팅
``` 
인수테스팅은 시스템을 사용하는 고객이나 사용자가 전담하여 수행하는 경우가가 대부분(다른 이해관계자의 참여도 가능)
```
- 인수테스팅의 목적
	- 결함을 찾는것이 아니라 시스템을 배포하거나 실제 사용할만한 준비가 되었는지에 대해 평가하고
	- 시스템이나 시스템 일부 또는 특정한 비기능적인 특성에 대해 '확신'을 얻는 것이다.
- **인수테스팅의 전형적인 형태**
1) 사용자 인수 테스팅
	- 일반적으로 비즈니스 사용자가 시스템 사용의 적절성을 확인한다.
2) 운영상의(인수) 테스팅
	- 시스템 관리자에 의한 테스트 활동으로, 일반적인 테스트 항목은(백업/복원, 재난복구, 사용자관리, 유지보수작업, 보안취약성에 대한 정기적인 점검)이 있다.
3) 계약인수 테스팅과 규정인수 테스팅
	- 계약인수 테스팅은 맞춤식-개발 SW가 계약상의 인수통과조건을 준수하는지 확인하는 테스팅
	- 규정인수 테스팅은 준수해야하는 규정에 맞게 개발되었는지 확인하는 테스팅
4) 알파 테스팅과 베타 테스팅
	- 알파 테스팅 : 개발 조직 내에서 고객에 의해 수행
	- 베타 테스팅(필드 테스팅) : 실제 환경에서 사용자 혹은 잠재 고객에 의해 수행





## 3.1 정적 기법과 프로세스
- `정적 기법은 소프트웨어를 실행하지 않고 테스팅하는 기법으로, (리뷰와 정적분석)이 있다.`
	- 리뷰 : 수동적 기법
	- 정적 분석 : 자동화 도구를 활용한 정적 분석

### 3.1.1 리뷰의 이점과 목적
- 리뷰는 코드를 포함하여 소프트웨어 개발 및 테스트 산출물을 검토하고 테스팅하는 방법이며, 동적 테스팅 전에 적절히 수행할 수 있다.
- 리뷰는 동적 테스팅에서 발견하기 어려운 개발 산출물(요구사항 명세 등)의 누락과 같은 결함을 발견할 수 있다.
- 개발 초기에 리뷰를 통해 발경하는 결함의 수정 비용과 리스크는 비교적 낮다.(이점)
- 리뷰의 대상은 **요구사항 명세, 설계 명세, 코드, 테스트 명세, 테스트 케이스, 테스트 스크립트, 사용자 가이드나 웹페이지 등** 모든 소프트웨어 개발 및 테스트 산출물이다.

- `리뷰의 이점`
	- 조기 결함 발견 및 수정
	- 개발 생산성 향상
	- 개발 기간 단축
	- 테스팅 비용 단출 및 시간 단축
	- 개발 수명주기 전체에 걸친 비용 감소
	- 결함 감소(품질 향상)
	- 커뮤니케이션 향상 

- `리뷰의 목적` 
	- 리뷰와 정적분석, 동적 테스팅 모두 **결함 발견**이라는 동일한 목적을 갖고 있다.
	- 정적 기법은 동적 테스팅과 달리 장애(Failures) 자체보다는 장애의 원인인 결함을 발견한다.

- `리뷰를 통해 발경하기 쉬운 결함의 종류`
	- 표준 위반
	- 요구사항 결함
	- 개발 설계(Design) 결함
	- 불충분한 유지보수성
	- 부정확한 인터페이스 명세

### 3.1.2 리뷰와 테스팅
- 최근에는 결함을 일찍 발견하여 테스팅 비용과 전체 개발 프로젝트 비율을 줄이기 위한 다각적인 시도가 이뤄지고 있다.
- 개발 산출물을 테스트하는 **정적 기법**이 **결함 예방의 위한 테스팅의 중심**을 이룬다.
- 조기 테스트 설계는 코딩 전에 시스템과 관련된 문서를 먼저 테스트하여 시스템에 유입될 수 있는 결함을 미리 예방할 수 있다.
- 개발 프로젝트 앞단에서 시스템 명세를 테스트하는 과정에서 결함을 찾는 것은 물론, 이 과정을 통해 **테스트 케이스를 도출할 수 있게 되어 추후 테스트 실행 시 시간을 절약**할 수 있다.

## 3.2 리뷰 프로세스
- 리뷰는 공식적인 것부터 매우 비공식적인 것까지 다양한 형태를 가진다.
- 리뷰를 통해 달성하고자 하는 **목적에 따라 리뷰 방식이 정해진다.**각각의 목적에 맞는 리뷰 방식과 형식을 따르도록 한다.
- **체계적인 리뷰를 진행**한다면 고품질 소프트웨어 개발과 비용 절감은 물론 개발 기간 단축이라는 효과로 이어질 수 있다.

### 3.2.1 공식적인 리뷰의 단계
```
- 프로세스 전반의 `리뷰 활동에 대한 계획`은 테스트 프로세스의 `테스트 계획 단계에 수립되어 테스트 계획서에 해당 내용이 명시`되어야한다.
- 정적 테스트 프로세스는 크게 `[1. 정정 테스트 준비단계/2. 리뷰 분석 단계/3. 후속 처리 확인 단계]`의 3단계로 구성된다.
- **리뷰를 성공적으로 진행하기 위해서는 절차를 준수**해야한다.
```

#### <공식적 리뷰 절차>
- 1. `계획 활동`
	- 참가 인원을 선정하고 역할을 할당
	- 인스펙션과 같은 공식적인 리뷰에서는 시작 및 종료기준을 정의한다.
	- 어떤 부분의 문서 및 코드를 리뷰할것인지를 정한다.
- 2. `시작(Kick-Off)`
	- 문서를 배보한다.
	- 리뷰의 목표, 절차 및 문서를 참석자에게 설명한다.
	- 좀 더 공식적인 리뷰에서 시작 기준을 점검한다.
- 3. `개별 준비`
	- 미팅 전에 참석자 별로 사전 리뷰 활동을 통해 잠재적인 결함이나 회의에서 제기할 질문과 의견을 기록한다.=
- 4. `리뷰 미팅`
	- 개별 준비 내용을 토의하고 이에 대한 결과를 문서로 기록한다.
	- 보다 공식적인 리뷰에서는 상세 회의록을 작성한다.
	- 미팅 참석자들은 간단하게 결함을 기록하고, 결함 처리 방안을 제안하며 결함 여부에 대해서 결정을 내린다.
- 5. `재작업(Rework)`
	- 발견된 결함을 대상 문서의 저자가 수정한다.(=결함 수정)
- 6. `후속처리 확인(Follow-up)`
	- 발견된 결함이 처리되었는지를 확인하고, 보다 공식적인 리뷰에서는 관련 측정치(메트릭)를 수집하고 리뷰 종료기준을 점검한다.

### 3.2.2 역할과 책임
```
- 리뷰는 역할과 책임이 명확해야 성공적인 성과를 낸다.
- 공식적일수록 역할과 책임이 분명하며 모든 참여자가 리뷰 미팅 진행을 위해 정해진 역할을 맡게 되며
- 일반적으로 모든 참여자는 검토자의 역할을 병행한다.
```

- 1. `관리자(Manager)`
	- 리뷰의 실행 여부를 결정하고, 프로젝트 일정에 리뷰 시간을 할당하고
	- 리뷰의 목적 달성 여부를 확인하고 승인한다.
	- 결정권자
- 2. `중재자(Moderator)`
	- 문서의 리뷰를 리드한다. 
	- 즉, 리뷰를 계획하고, 미팅을 진행하고, 미팅 후속 조치의 처리 여부등을 추적하고 관리한다.
	- 필요 시 참석자들의 다양한 관점을 중재하며, 많은 경우 리뷰의 성패를 좌우한다. 
	- MC이자 책임자
- 3. `저자(Autor)'
	- 리뷰 대상 문서(산출물)의 작성자 또는 책임자
	- 개발자
- 4. `검토자(Reviewer)`
	- 해당 분야의 기술적 or 비즈니스적 배경을 갖춘 사람으로, 리뷰 대상에서 인시던트(결함 포함)을 발견하고 기술하는 사람 
	- 검토자는 리뷰 프로세스에서 다양한 관점과 역할을 대표하도록 선발돼야 하고, 특정 리뷰 미팅에 제한적으로 참여하기보다는 모든 형태의 리뷰 미팅에 참석하여 리뷰 활동을 수행
- 5. `기록자(Scribe of Recorder)`
	- 리뷰 미팅에서 발견된 모든 이슈, 문제점, 미해결점 등을 기록하고 문서화 한다.

```
테스트 전문가는 일반적으로 검토자로서 리뷰에 참여. 다른 검토자들과는 달리 테스팅 관점에서 발견한 결함과 검토 의견을 갖고 리뷰에 참여
즉, 리뷰 대상을 테스트 케이스로 만들면서 발견한 '다른 종류'의 결함을 가지고 리뷰에 기여
향후 테스팅에서 사용할 TC를 간접적으로 검토받고 원할한 테스트 수행을 준비하게 되는 것
테스트 전문가가 리뷰 과정에서 지속적으로 참여해온 경우, 이미 준비된 TC로 단기간에 테스팅을 진행할 수 있게된다.
(사용하지 못하는 경우도 있지만, 대부분의 리뷰 과정에 참여했기 때문에 풍부한 이해를 바탕으로 효과적인 테스팅을 할 수 있다.)
```

### 3.2.4 리뷰의 유형
- [비공식적 리뷰 / 기술적 리뷰 / 워크쓰루 / 인스펙션] 이 존재
- 1. `비공식적 리뷰`
	- 공식적인 절차가 없다.
	- 페어 프로그래밍에 의한 리뷰이거나, 기술 선임자가 설계와 코드를 리뷰하는 것일 수 있음
	- 선택적으로 문서화 가능 
	- 리뷰하는 사람에 따라 성과가 좌우됨(개인의 기량이 중요) 
	- **주요 목적 : 기술적 문제 해결, 토론, 의사결정, 대안 평가,결함 발견, 명세서 또는 표준과의 적합성 검토**

- 2. `기술적 리뷰`
	- 동료와 기술 전문가가 참여하는, 결함 발견을 위한 문서화되고 정의된 프로세스가 존재함
	- 관리자 개입 없는 동료 검토 형태로 수행할 수 있음
	- 이상적으로는 저자가 아닌 중재자가 미팅을 주도함
	- 실무에서 공식적 또는 비공식적일 수 있음, 공식적일 경우 문서화 필수
	- **주요 목적 : 기술적 문제 해결, 토론, 의사 결정, 대안 평가, 결함 발견, 명세서 또는 표준과의 적합성 검토**

- 3. `워크쓰루`
	- 저자(=개발자)에 의한 진행 및 제어 => 중재자 없음
	- 성격 : 시나리오 사용, 예행 연습, 동료 그룹 검토
	- 시간, 인원 등에 제한이 없고 상황에 따라 변경할 수 있는 세션
	- **주요 목적 : 학습, 시스템에 대한 이해 향상, 결함 발견**

- 4. `인스펙션`
	- 훈련된 중재자(=책임자에 의한 진행 및 제어
	- 역할이 정의되어 있음. 주료 동료 검사
	- 메트릭을 수집하고 활용함
	- 체크리스트와 규칙을 기반으로, 시작과 종료 조건이 있는 정식 프로세스 존재
	- 미팅 전 준비 과정 필요
	- **주요 목적 : 결함 발견**

```
>>공식적인 리뷰에서의 일반적인 역할과 책임은 인스펙션에도 그대로 적용되며, 특징적인 것은 검토자와는 별도로 테스터의 역할을 두고 있다는 점.
- 테스터는 '어떻게 테스트할 것인가'의 관점을 가지고 인스펙션 회의 시 질문하는 것으로 역할이 정의
- 테스트 전문가는 각종 개발 산출물들을 테스트 베이시스로 두고, 테스트를 설계하고 TC를 작성하면서 발견되는 결함을 보고
- 인스펙션 대상은 모든 개발 산출물과 테스트 산출물 등이 있다.
- 인스펙션은 리스크 분석 결과를 활용하여 장애 발생 가능성이 높고 발생한 장애로 인한 영향이 심각할 수 있는 부분을 중심으로 진행되어야 한다.
```

```
>>워크쓰루, 기술적 리뷰, 그리고 인스펙션은 같은 조직 레벨에서 동등한 그룹 동료들 사이에서 수행될 수 있고,
- 이러한 종류의 리뷰를 '동료검토(Peer review)'라고 한다. 
- 테스트 엔지니어를 포함하여 리뷰 활동을 위한 적절한 리소스 할당 내용도 테스트 계획서에 명시하여야 한다.
- 리뷰에 투입할 수 있는 리소스가 제한되어 있으므로 리뷰도 리스크 기반으로 접근하는 것이 필요하다.
- 리스크가 높은 개발 산출물의 특정 부분은 강도 높게 공식적인 리뷰 기법을 적용하고
- 리스크가 낮은 부분은 비공식적인 리뷰를 진행한다.
- 이와 같이 리뷰를 유형에 따라 리스크를 반영하여 전략적으로 적용한다면 리뷰의 효과를 높일 수 있다.
```

### 3.2.4 리뷰의 성공 요소
> 리뷰가 성공적이기 위한 3가지 요소
1. 수행하고자 하는 리뷰 대상 및 목적에 부합하는 리뷰 형식을 선택
2. 리뷰 참여자들의 역할과 책임을 명확하게 한 후
3. 리뷰 프로세스에 준하여 리뷰를 진행

- 이밖에도 성공적으로 리뷰를 진행하기 위해서는 참여자 수를 리뷰 경험과 조직 특성을 고려하여 3~5명 정도로 제한하고
- 모든 참여자가 기록을 습관화하고, 개별 준비를 성실하게 수행하도록 유도하여야 한다.

## 3.3 도구에 의한 정적 분석
- 정적분석은 소프트웨어를 실제적으로 실행하지 않는 상태에서 도구의 지원으로 수행하는 것
> 정적 분석의 목적 : 소프트웨어 소스코드와 모델에서 결함을 발견하는 것

- 1. 정적분석의 특징
	- 동적 테스팅으로 찾기 힘든 결함을 발견함
	- 리뷰와 마찬가지로 정적 분석은 장애보다는 결함을 발견함
	- 도구의 도움을 받아 수행함
	- 정적 분석 도구는 프로그램 코드를 분석하는 것은 물론, HTML이나 XML과 같이 생성된 결과물도 분석함
- 2. 정적분석의 가치
	- 테스트 실행 전에 조기 결함 발견
	- 높은 복잡도 측정치와 같은 매트릭을 계산하여 코드와 설계의 의심스러운 부분에 대한 조기 경보
	- 동적 테스팅으로 발결한기 어려운 결함 발견
	- 소프트웨어 모델상의 의존도와 불일치성 발견
	- 코드와 설계 유지보수성 향상
	- 결함 예방 가능
- 3. 정적 분석 도구를 통해 발견되는 전형적인 결함
	- 정의되지 않는 값으로 변수 참조
	- 모듈과 컴포넌트 간에 일관되지 않은 인터페이스
	- 사용되지 않는 변수
	- 사용되지 않는 코드 
	- 코딩 표준 위반
	- 보안 취약성
	- 코드와 소프트웨어 모델의 구문 규칙 위반

```
>> 정적 분석 도구는 정의된 규칙이나 코딩 표준을 준수하는지 확인하느 용도로
- 컴포넌트 테스팅과 통합 테스팅 동안에 주로 개발자에 의해 사용
- 소프트웨어 모델링는 동안에 설계자에 의해 사용
```

## 4. 테스트 기법(정적 테스트와 동적 테스트)

```
* 정적 테스트
- 소프트웨어를 실행하지 않고 테스팅하는 기법
- 실제 시스템이 구현되기 전에 요구사항 정의서, 설계서, 소스 코드 등의 개발 산출물을 테스팅하는 것을 의미

* 동적 테스트
- 실제 구현된 시스템(프로그램)을 실행하여 테스팅하는 기법
```

### 정적 테스트(리뷰, 정적분석)
```
리뷰(Review)
- 여러 전문가들이 모여 코드를 포함하여 소프트웨어 개발 및 산출물을 검토하고 테스팅하여 결함을 검출하는 방법
```

* 1) 리뷰(Review)
	- 비공식적 리뷰
		- 공식적인 절차가 없다.
		- 저렴한 방법으로 일정 수준의 성과 달성을 위한 목적으로 진행함
	- 기술적 리뷰
		- 동료와 기술 전문가가 참여
		- 결함 발견을 위한 문서화되고 정의된 프로세스가 존재
		- 관리자 개입이 없는 동료 검토 형태로 수행할 수 있음
	- 워크쓰루(Workthrough) 
		- 인스펙션보다는 비형식적인 리뷰 방식
		- 저자에 의한 진행 및 제어
		- 결함 검출과 더불어 참가자들의 교육이나 지식 공유를 위해 수행되기도 함
	- 인스펙션
		- 리뷰 종류 중 가장 형식화된 리뷰 방식 동료 검토라고 할 수 있음
		- 저자가 아닌 훈련된 중재자에 의한 진행 및 제어	
		- 인스펙션 대상은 모든 개발 산출물과 테스트 산출물이다.

* 2) 정적분석	
	- 소프트웨어를 실행하지 않는 상태에서 자동화된 도구를 활용하여 정적 테스트를 수행하여 결함을 발견(예 : 프로그래머스 Debuging, 알고리즘 구현 후 여러 테스트 케이스를 자동으로 돌려보는 느낌)
	- 정적 분석의 목적 : 소프트웨어의 소스코드와 내부 결함을 발견하는 것

### 동적 테스트(명세기반, 구조기반, 경험기반)

* 1) 명세기반 테스트(=블랙박스 기법)
- `소스코드, 내부 구조를 참고하지 않고 사용자의 요구사항이 기술된 명세나 테스터의 경험을 바탕으로 TC를 결정하는 방법`
	- 동등 분할
	- 경계값 분석
	- 결정 테이블 테스트
	- 상태 전이 테스트
	- 분류 트리 기법	
	- 조합 테스트(페어 와이즈)
	- 시나리오 테스트
	- ...

* 2) 구조기반 테스트(=화이트박스 기법) 
- `구현된 소스코드와 내부 구조를 바탕으로 TC를 결정하는 방법`
	- 구문(문장) 커버리지
	- 결정 커버리지
	- 조건 커버리지
	- 조건/결정 커버리지
	- 변형 조건/결정 커버리지(MCDC)
	- 다중 조건 커버리지
	- 경로 커버리지

* 3) 경험기반 테스트
	- 오류 추정(Erorr Guessing) 
	- 탐색적 테스팅
	- 체크리스트 기반 테스팅

### 예시를 활용한 테스트 기법의 이해
* 1) 정적 테스팅(Static Testing)
	- `여러 개발자가 소프트웨어 프로젝트를 작업하는 중, 다른 개발자들은 코드를 리뷰하고 문서 검토를 수행하며 논리적 결함이나 문서화 누락 사항을 찾는다.`
	-  예 : 한 개발자가 작성한 코드가 특정한 상황에서 제대로 동작하지 않는다는 것을 정적 테스트를 통해 발견할 수 있다.

* 2) 동적 테스팅(화이트박스, 블랙박스, 경험기반)
	- 화이트박스(= 구조기반 테스트) 
		- 프로그램내에서 소스코드를 살펴보고 테스트 케이스를 작성
		- 예 : 계산기 프로그램에서 두 수를 더하는 함수(Function)이 존재한다면 이 함수가 내부적으로 정상적으로 동작하는지 테스트 케이스를 작성(= 화이트박스 테스트) 
		- 결과를 검증하는 것이 아닌 과정을 검증
	- 블랙박스(= 명세기반 테스트) 
		- 프로그램의 외부의 동작만을 검증
		- 예 : 계산기 프로그램에서 다양한 입력값을 제공하고, 예상 출력과 실제 출력을 비교하여 올바르게 동작하는지 확인(= 블랙박스 테스트) 
		- 결과를 기준으로 검증
	- 경험 기반 테스팅(Experience-Based Testing)
		- 개발자나 테스터의 경험과 직관으로 소프트웨어를 테스트하는 접근 방식
		- 표준화된 테스트 기법이나 계획을 사용하는 것보다는 개인의 경험과 통찰력을 활용하여 테스트 케이스를 설계하고 결함을 찾는데 중점



	
